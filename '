use std::{
    iter::{Map, StepBy},
    slice::Iter,
};

use crate::{Grid, Line, Order, Position};

type RowIter<'a, T> = Iter<'a, T>;
type ColIter<'a, T> = StepBy<Iter<'a, T>>;

impl<T> Grid<T> {
    pub fn iter_row<'a>(&'a self, row: usize) -> RowIter<'a, T> {
        let start = row * self.cols;
        let end = start + self.cols;

        self.data[start..end].iter()
    }

    pub fn iter_rows<'a>(&'a self) -> impl Iterator<Item = RowIter<'a, T>> {
        (0..self.rows).map(move |row| self.iter_row(row))
    }

    pub fn iter_col<'a>(&'a self, col: usize) -> ColIter<'a, T> {
        let start = col;
        self.data[start..].iter().step_by(self.cols)
    }

    pub fn iter(&self) -> impl Iterator<Item = &T> + '_ {
        self.data.iter()
    }

    pub fn iter_mut(&mut self) -> impl Iterator<Item = &mut T> + '_ {
        self.data.iter_mut()
    }
}

#[derive(Debug, Clone)]
pub enum LineIter<'a, T> {
    Row(RowIter<'a, T>),
    Col(ColIter<'a, T>),
    Empty,
}

impl<T> Grid<T> {
    pub fn iter_line<'a>(&'a self, line: Line) -> LineIter<'a, T> {
        match line {
            Line::Row(row) if row < self.rows => {
                let iter = self.iter_row(row);
                LineIter::Row(iter)
            }
            Line::Col(col) if col < self.cols => {
                let iter = self.iter_col(col);
                LineIter::Col(iter)
            }
            _ => LineIter::Empty,
        }
    }

    pub fn iter_lines<'a>(&'a self, order: Order) -> impl Iterator<Item = LineIter<'a, T>> {
        match order {
            Order::RowMajor => (0..self.rows).map(move |row| {
                let iter = self.iter_row(row);
                LineIter::Row(iter)
            }),
            Order::ColMajor => (0..self.cols).map(move |col| {
                let iter = self.iter_col(col);
                LineIter::Col(iter)
            }),
        }
    }
}
